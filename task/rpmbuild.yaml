---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  annotations:
    tekton.dev/pipelines.minVersion: 0.12.1
    tekton.dev/tags: rpm-build
  name: rpmbuild
  labels:
    build.appstudio.redhat.com/multi-platform-required: "true"
    build.appstudio.redhat.com/build_type: "rpm"
spec:
  description: |-
    RPM Build task.
  params:
    - description: Package name being built
      name: package-name
      type: string
    - description: The platform/architecture we build for
      name: PLATFORM
      type: string
    - description: The branch name we build against/from
      name: target-branch
      type: string
    - description: Mock configuration template file (trusted-artifact, string content)
      name: mock-config-template-file
      type: string
    - description: RPM Build environment OCI image to run scripts in
      name: script-environment-image
      type: string
    - description: Build without network access
      name: hermetic
      type: string
    - description: The Trusted Artifact URI pointing to the artifact with the source and deps.
      name: dependencies-artifact
      type: string
    - description: The Trusted Artifact URI pointing to the artifact with the deps calculation.
      name: calculation-artifact
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored.
      type: string
    - name: ociArtifactExpiresAfter
      description: How long Trusted Artifacts should be retained
      type: string
    - name: specfile
      description: |
        Name of specfile when specfile doesn't have the same prefix name as package name.
        Default is null and package-name.spec is used.
      type: string
    - name: build-number
      description: |
        Build number for FESCo 3501 %buildrelease support. Empty for first build
        of an NVR (no suffix), "1" for first rebuild (+build1), etc.
      type: string
      default: ""
  results:
    - name: rpmbuild-artifact
      description: The Trusted Artifact URI pointing to the artifact with the result of the build.
      type: string
  # 'timeout: "72h"' doesn't work for task files.  Per-step timeouts work, but
  # we have to configure per-Task timeout in the Pipeline
  # file.
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
  steps:
    - name: use-trusted-artifact-source
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - use
        - $(params.dependencies-artifact)=/var/workdir/source
    - name: use-trusted-artifact-results
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - use
        - $(params.calculation-artifact)=/var/workdir/results
    - name: use-trusted-artifact-mock-config
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - use
        - $(params.mock-config-template-file)=/var/workdir/mock-config
    - name: mock-build
      image: "quay.io/redhat-appstudio/multi-platform-runner:01c7670e81d5120347cf0ad13372742489985e5f@sha256:246adeaaba600e207131d63a7f706cffdcdc37d8f600c56187123ec62823ff44"
      script: |
        #!/bin/bash
        set -ex
        if test "$(params.PLATFORM)" = localhost; then
          # do nothing (architecture not selected)
          exit 0
        fi
        mkdir -p ~/.ssh
        if [ -e "/ssh/error" ]; then
          #no server could be provisioned
          cat /ssh/error
          exit 1
        elif [ -e "/ssh/otp" ]; then
         curl --cacert /ssh/otp-ca -XPOST -d @/ssh/otp $(cat /ssh/otp-server) >~/.ssh/id_rsa
         echo "" >> ~/.ssh/id_rsa
        else
          cp /ssh/id_rsa ~/.ssh
        fi

        arch=x86_64
        case $(params.PLATFORM) in
          *s390x) arch=s390x ;;
          *ppc64le) arch=ppc64le ;;
          *arm64) arch=aarch64 ;;
        esac

        chmod 0400 ~/.ssh/id_rsa
        export SSH_HOST=$(cat /ssh/host)
        export HOMEDIR=$(cat /ssh/user-dir)
        export SSH_ARGS="-o StrictHostKeyChecking=no"
        remote_cmd() { ssh $SSH_ARGS "$SSH_HOST" "$@" ; }
        send() { rsync -rva "$1" "$SSH_HOST:$2" ; }
        receive() { rsync -rva "$SSH_HOST:$1" "$2" ; }

        if [ "$SSH_HOST" == "localhost" ] ; then
          echo "Running at local host is not supported"
          exit 1
        fi

        workdir=/var/workdir

        remote_cmd echo "Hello from the other side!"

        # Allow mockbuilder (group mock) to read sources, and write results
        remote_cmd mkdir "$HOMEDIR/results" "$HOMEDIR/source" "$HOMEDIR/var_lib_mock"
        remote_cmd podman unshare setfacl -m g:135:r-x -m default:g:135:r-x "$HOMEDIR/source"
        remote_cmd podman unshare setfacl -m g:135:rwx -m default:g:135:rwx "$HOMEDIR/results"
        remote_cmd podman unshare chgrp 135 "$HOMEDIR/var_lib_mock"
        remote_cmd podman unshare chmod g+rwx "$HOMEDIR/var_lib_mock"

        send "$workdir/source/" "$HOMEDIR/source"

        mock_img=$(params.script-environment-image)
        # podman pull has --retry=3 as a default, nevertheless it works only for download of blobs,
        # if manifest download fails it will not be applied
        for i in {1..5} ; do
            remote_cmd podman pull "$mock_img" && break
            sleep_time=$((i ** 2))
            echo "Retrying in $sleep_time seconds."
            sleep $sleep_time
        done

        # Set the PID limit. 16384 is the maximum supported value on OpenShift
        # to prevent resource exhaustion errors when building large packages like gcc.
        PID_LIMIT_CONST=16384
        podman_params=(
            -u mockbuilder
            --pids-limit=$PID_LIMIT_CONST
            -v "$HOMEDIR/source:/source"
            -v "$HOMEDIR/results:/results"
            -v "$HOMEDIR/var_lib_mock:/var/lib/mock"
            --init --privileged --rm -ti
            --security-opt label=disable "$mock_img"
        )

        if test "$(params.specfile)" != "null" ; then
          specfile_name=$(params.specfile)
        else
          specfile_prefix=$(params.package-name)
          specfile_name="${specfile_prefix}.spec"
        fi

        # Build the mock command with optional buildnumber macro (FESCo 3501)
        mock_define_args=""
        if [ -n "$(params.build-number)" ]; then
          mock_define_args="--define 'buildnumber $(params.build-number)'"
          echo "Using build number: $(params.build-number)"
        fi

        success=true
        if "$(params.hermetic)"; then
          # Give mockbuilder rights to consume buildroot.
          remote_cmd mkdir "$HOMEDIR/buildroot"
          remote_cmd podman unshare setfacl -m g:135:r-x -m default:g:135:r-x "$HOMEDIR/buildroot"
          send "$workdir/results/$arch/results" "$HOMEDIR/buildroot"

          remote_cmd podman run --network=none \
                                -v "$HOMEDIR/buildroot:/buildroot" \
                                "${podman_params[@]}" \
              mock --hermetic-build \
                  /buildroot/results/buildroot_lock.json \
                  /buildroot/results/buildroot_repo \
                  $mock_define_args \
                  --spec /source/$specfile_name \
                  --sources /source --resultdir /results \
          || success=false
        else
          # Instantiate the given Mock config template for our architecture.
          sed "s|@ARCH@|$arch|" "$workdir/mock-config/mock.cfg" > "$workdir/mock.cfg"
          send "$workdir/mock.cfg" "$HOMEDIR/mock.cfg"
          remote_cmd podman run -v "$HOMEDIR/mock.cfg:/mock.cfg" \
                                "${podman_params[@]}" \
              mock -r /mock.cfg \
                  $mock_define_args \
                  --spec /source/$specfile_name \
                  --sources /source --resultdir /results \
          || success=false
        fi

        # display dnf logs (no matter the mock exit status), and propagate the
        # mock failure (terminates the whole script)
        remote_cmd tar xfO $HOMEDIR/results/chroot_scan.tar.gz
        $success

        resultdir="$workdir/results/$arch"
        mkdir -p "$resultdir"
        receive "$HOMEDIR/results/" "$resultdir"
      volumeMounts:
        - mountPath: /ssh
          name: ssh
          readOnly: true
    - name: create-trusted-artifact
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - create
        - --store
        - $(params.ociStorage)
        - $(results.rpmbuild-artifact.path)=/var/workdir/results
      env:
        - name: IMAGE_EXPIRES_AFTER
          value: $(params.ociArtifactExpiresAfter)
  volumes:
    - name: ssh
      secret:
        optional: false
        secretName: multi-platform-ssh-$(context.taskRun.name)
    - name: workdir
      emptyDir: {}
