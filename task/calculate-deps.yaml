---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  annotations:
    tekton.dev/pipelines.minVersion: 0.12.1
    tekton.dev/tags: rpm-build
  name: calculate-deps
  labels:
    build.appstudio.redhat.com/multi-platform-required: "true"
spec:
  description: |-
    RPM calculate deps task.
  params:
    - description: Package name being built
      name: package-name
      type: string
    - description: The platform/architecture we build for
      name: PLATFORM
      type: string
    - description: The branch name we build against/from
      name: target-branch
      type: string
    - description: Mock configuration template file (trusted-artifact, string content)
      name: mock-config-template-file
      type: string
    - description: RPM Build environment OCI image to run scripts in
      name: script-environment-image
      type: string
    - description: The Trusted Artifact URI pointing to the artifact with the rpm deps and source.
      name: dependencies-artifact
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored.
      type: string
    - name: ociArtifactExpiresAfter
      description: How long Trusted Artifacts should be retained
      type: string
    - name: specfile
      description: |
        Name of specfile when specfile doesn't have the same prefix name as package name.
        Default is null and package-name.spec is used.
      type: string
    - name: build-number
      description: |
        Build number for FESCo 3501 %buildrelease support. Empty for first build
        of an NVR (no suffix), "1" for first rebuild (+build1), etc.
      type: string
      default: ""
  results:
    - name: calculation-artifact
      description: The Trusted Artifact URI pointing to the artifact with the result of the deps calculation.
      type: string
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
  steps:
    - name: use-trusted-artifact
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - use
        - $(params.dependencies-artifact)=/var/workdir/source
    - name: use-trusted-artifact-mock-config
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - use
        - $(params.mock-config-template-file)=/var/workdir/mock-config
    - name: mock-build
      image: "quay.io/redhat-appstudio/multi-platform-runner:01c7670e81d5120347cf0ad13372742489985e5f@sha256:246adeaaba600e207131d63a7f706cffdcdc37d8f600c56187123ec62823ff44"
      script: |
        #!/bin/bash
        set -ex
        if test "$(params.PLATFORM)" = localhost; then
          # do nothing (architecture not selected)
          exit 0
        fi
        mkdir -p ~/.ssh
        if [ -e "/ssh/error" ]; then
          #no server could be provisioned
          cat /ssh/error
          exit 1
        elif [ -e "/ssh/otp" ]; then
         curl --cacert /ssh/otp-ca -XPOST -d @/ssh/otp $(cat /ssh/otp-server) >~/.ssh/id_rsa
         echo "" >> ~/.ssh/id_rsa
        else
          cp /ssh/id_rsa ~/.ssh
        fi

        arch=x86_64
        case $(params.PLATFORM) in
          *s390x) arch=s390x ;;
          *ppc64le) arch=ppc64le ;;
          *arm64) arch=aarch64 ;;
        esac

        chmod 0400 ~/.ssh/id_rsa
        export SSH_HOST=$(cat /ssh/host)
        export HOMEDIR=$(cat /ssh/user-dir)
        export SSH_ARGS="-o StrictHostKeyChecking=no"
        remote_cmd() { ssh $SSH_ARGS "$SSH_HOST" "$@" ; }
        send() { rsync -rva "$1" "$SSH_HOST:$2" ; }
        receive() { rsync -rva "$SSH_HOST:$1" "$2" ; }

        if [ "$SSH_HOST" == "localhost" ] ; then
          echo "Running at local host is not supported"
          exit 1
        fi

        workdir=/var/workdir

        remote_cmd echo "Hello from the other side!"

        # Instantiate the given Mock config template for our architecture.
        sed "s|@ARCH@|$arch|" "$workdir/mock-config/mock.cfg" > "$workdir/mock.cfg"
        send "$workdir/mock.cfg" "$HOMEDIR/mock.cfg"

        # Allow mockbuilder (group mock) to read sources, and write results
        remote_cmd mkdir "$HOMEDIR/results" "$HOMEDIR/source"
        remote_cmd podman unshare setfacl -m g:135:r-x -m default:g:135:r-x "$HOMEDIR/source"
        remote_cmd podman unshare setfacl -m g:135:rwx -m default:g:135:rwx "$HOMEDIR/results"

        send "$workdir/source/" "$HOMEDIR/source"

        mock_img=$(params.script-environment-image)
        # podman pull has --retry=3 as a default, nevertheless it works only for download of blobs,
        # if manifest download fails it will not be applied
        for i in {1..5} ; do
            remote_cmd podman pull "$mock_img" && break
            sleep_time=$((i ** 2))
            echo "Retrying in $sleep_time seconds."
            sleep $sleep_time
        done

        if test "$(params.specfile)" != "null" ; then
          specfile_name=$(params.specfile)
        else
          specfile_prefix=$(params.package-name)
          specfile_name="${specfile_prefix}.spec"
        fi

        # Build the mock command with optional buildnumber macro (FESCo 3501)
        mock_define_args=""
        if [ -n "$(params.build-number)" ]; then
          mock_define_args="--define 'buildnumber $(params.build-number)'"
          echo "Using build number: $(params.build-number)"
        fi

        success=true
        remote_cmd podman run -u mockbuilder \
                              -v "$HOMEDIR/source:/source" \
                              -v "$HOMEDIR/results:/results" \
                              -v "$HOMEDIR/mock.cfg:/mock.cfg" \
                              --init --privileged --rm -ti "$mock_img" \
            mock -r /mock.cfg \
                $mock_define_args \
                --spec /source/$specfile_name \
                --sources /source --resultdir /results \
                --calculate-build-dependencies \
        || success=false

        # display dnf logs (no matter the mock exit status), and propagate the
        # mock failure (terminates the whole script)
        remote_cmd "tar xvfO '$HOMEDIR'/results/chroot_scan.tar.gz 2>&1 | cat"
        $success

        remote_cmd podman run -v "$HOMEDIR/results:/results" \
                              --privileged --rm -ti "$mock_img" \
            mock-hermetic-repo \
            --lockfile /results/buildroot_lock.json \
            --output-repo /results/buildroot_repo

        resultdir=$workdir/results/$arch/results
        mkdir -p "$resultdir"
        # Send only repo and lockfile, ignore other artifacts
        receive "$HOMEDIR/results/buildroot_lock.json" "$resultdir/buildroot_lock.json"
        receive "$HOMEDIR/results/buildroot_repo" "$resultdir"
        cat "$resultdir/buildroot_lock.json"
      volumeMounts:
        - mountPath: /ssh
          name: ssh
          readOnly: true
      computeResources:
        requests:
          ephemeral-storage: 5Gi
    - name: create-trusted-artifact
      image: quay.io/redhat-appstudio/build-trusted-artifacts:latest@sha256:9b180776a41d9a22a1c51539f1647c60defbbd55b44bbebdd4130e33512d8b0d
      args:
        - create
        - --store
        - $(params.ociStorage)
        - $(results.calculation-artifact.path)=/var/workdir/results
      env:
        - name: IMAGE_EXPIRES_AFTER
          value: $(params.ociArtifactExpiresAfter)
  volumes:
    - name: ssh
      secret:
        optional: false
        secretName: multi-platform-ssh-$(context.taskRun.name)
    - name: workdir
      emptyDir: {}
